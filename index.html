<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√Ålvaro e o Vaso Sanit√°rio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            overflow: hidden; /* Prevent scrolling if canvas is slightly larger */
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            position: relative; /* For countdown positioning */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; /* Ensure it takes full width of wrapper */
        }

        canvas {
            background-color: #e0f2f7; /* Light blue background for the board */
            border: 5px solid #a7d9ed;
            border-radius: 15px;
            display: block;
            touch-action: none; /* Prevent browser default touch actions */
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px; /* Match canvas max-width */
            margin-bottom: 15px;
            font-size: 1.25rem; /* text-xl */
            font-weight: bold;
            color: #333;
        }

        .countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem; /* Large font size for countdown */
            font-weight: bold;
            color: rgba(0, 0, 0, 0.7);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through */
        }

        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem; /* text-5xl */
            font-weight: bold;
            color: #d32f2f; /* Red color for game over */
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px 40px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 20;
            display: none; /* Hidden by default */
        }

        .restart-button {
            margin-top: 20px;
            padding: 12px 25px;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            display: none; /* Hidden by default */
        }

        .restart-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        /* Character Selection Screen */
        .character-selection-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .character-selection-screen h2 {
            font-size: 2.5rem;
            color: #333;
            margin-bottom: 25px;
            font-weight: bold;
        }

        .character-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 500px;
        }

        .character-button {
            background-color: #f8f8f8;
            border: 2px solid #ddd;
            border-radius: 15px;
            padding: 15px 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem; /* Emoji size */
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .character-button:hover {
            background-color: #e6e6e6;
            border-color: #b3b3b3;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .character-button span {
            font-size: 1rem; /* Name size */
            font-weight: 600;
            color: #555;
            margin-top: 5px;
        }

        /* Responsive adjustments for character selection */
        @media (max-width: 768px) {
            .character-selection-screen {
                padding: 20px;
            }
            .character-selection-screen h2 {
                font-size: 2rem;
            }
            .character-buttons {
                grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
                gap: 15px;
            }
            .character-button {
                font-size: 2rem;
                padding: 10px 5px;
            }
            .character-button span {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <!-- Character Selection Screen -->
        <div id="characterSelectionScreen" class="character-selection-screen">
            <h2>Escolha seu Personagem</h2>
            <div id="characterButtons" class="character-buttons">
                <!-- Character buttons will be inserted here by JavaScript -->
            </div>
        </div>

        <!-- Main Game Container (initially hidden) -->
        <div id="gameContainer" class="game-container" style="display: none;">
            <div class="game-info">
                <span>Vasos pegos: <span id="score">0</span></span>
            </div>
            <canvas id="gameCanvas"></canvas>
            <div id="countdown" class="countdown-display">3</div>
            <div id="gameMessage" class="game-message"></div>
            <button id="restartButton" class="restart-button">Jogar Novamente</button>
        </div>
    </div>

    <script>
        // Get canvas and its context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get info elements
        const scoreDisplay = document.getElementById('score');
        const countdownDisplay = document.getElementById('countdown');
        const gameMessage = document.getElementById('gameMessage');
        const restartButton = document.getElementById('restartButton');

        // New elements for character selection
        const gameContainer = document.getElementById('gameContainer');
        const gameInfo = document.querySelector('.game-info'); // Select it here
        const characterSelectionScreen = document.getElementById('characterSelectionScreen');
        const characterButtonsContainer = document.getElementById('characterButtons');

        // Game settings
        const boardSize = 600; // Large board
        canvas.width = boardSize;
        canvas.height = boardSize;

        const cellSize = 20; // Size of each grid cell for movement
        const characterSize = cellSize; // √Ålvaro's size, now equal to cell size for perfect grid movement
        const toiletSize = cellSize * 2; // Toilet size
        const poopSize = cellSize; // Poop emoji size, also equal to cell size

        // Global character data with updated emojis and added √ârico
        const characterData = [
            { name: '√Ålvaro', emoji: 'üèÉ‚Äç‚ôÇÔ∏è' },
            { name: 'Guilherme', emoji: 'ü•Å' }, // Bateria
            { name: 'Franciela', emoji: 'üë∑‚Äç‚ôÄÔ∏è' }, // Engenheira
            { name: 'Pandora', emoji: 'üêº' },
            { name: 'Newton', emoji: 'üòê' }, // Cara de t√©dio
            { name: 'Larissa', emoji: 'üéæ' }, // Raquete de paddle/t√™nis
            { name: '√ârico', emoji: 'üë®‚Äçüî¨' } // Cientista
        ];

        const poopEmoji = 'üí©'; // Poop emoji remains constant
        const toiletEmoji = 'üöΩ'; // Toilet emoji remains constant

        let selectedCharacter = null; // Will store the chosen character object { name, emoji }

        let alvaro = {
            x: 0, // Initialized in startGame
            y: 0, // Initialized in startGame
            dx: 0,
            dy: 0,
            baseMoveDelay: 250, // Initial delay in ms between √Ålvaro's steps (slower start)
            moveDelay: 250,      // Current delay
            minMoveDelay: 50,    // Fastest speed limit for √Ålvaro (50ms = 20 steps/sec)
            lastX: 0, // Store previous grid position for poop
            lastY: 0  // Store previous grid position for poop
        };

        let toilet = {
            x: 0, // Initialized in startGame
            y: 0, // Initialized in startGame
            dx: 0, // Direction x
            dy: 0, // Direction y
            speed: cellSize / 4 // Initial toilet speed, moves slower than √Ålvaro
        };

        let score = 0;
        let countdown = 3;
        let gameOver = false;
        let poops = []; // Array to store poop emoji positions
        let toiletMoveInterval; // Interval for toilet's random movement
        let countdownInterval; // Interval for countdown timer
        let alvaroMoveIntervalId; // Interval ID for √Ålvaro's continuous movement
        let gameLoopId; // requestAnimationFrame ID for drawing loop


        // Function to set toilet's new random direction
        function setRandomToiletDirection() {
            const directions = [-1, 0, 1];
            toilet.dx = directions[Math.floor(Math.random() * directions.length)];
            toilet.dy = directions[Math.floor(Math.random() * directions.length)];
        }

        // Moves √Ålvaro based on his current dx/dy and drops poop if countdown is zero
        function moveAlvaro() {
            if (gameOver) return;

            // Store the exact previous position for poop placement
            alvaro.lastX = alvaro.x;
            alvaro.lastY = alvaro.y;

            // Move √Ålvaro by one cell
            alvaro.x += alvaro.dx;
            alvaro.y += alvaro.dy;

            // Keep √Ålvaro within bounds
            alvaro.x = Math.max(0, Math.min(alvaro.x, boardSize - characterSize));
            alvaro.y = Math.max(0, Math.min(alvaro.y, boardSize - characterSize));

            // If √Ålvaro hits a boundary and tries to move further, stop his movement in that direction.
            if ((alvaro.x === 0 && alvaro.dx < 0) || (alvaro.x === boardSize - characterSize && alvaro.dx > 0)) {
                alvaro.dx = 0;
            }
            if ((alvaro.y === 0 && alvaro.dy < 0) || (alvaro.y === boardSize - characterSize && alvaro.dy > 0)) {
                alvaro.dy = 0;
            }

            // If countdown is 0 and √Ålvaro is currently moving, √Ålvaro leaves poop emojis at the *just vacated* cell
            if (countdown <= 0 && (alvaro.dx !== 0 || alvaro.dy !== 0)) {
                // Calculate poop position to be centered on √Ålvaro's previous exact grid location
                const poopX = alvaro.lastX + (characterSize - poopSize) / 2;
                const poopY = alvaro.lastY + (characterSize - poopSize) / 2;
                poops.push({ x: poopX, y: poopY });
            }
        }


        // Initialize game (sets up character selection)
        function initializeGame() {
            gameOver = false;
            score = 0;
            scoreDisplay.textContent = score;
            countdown = 3;
            countdownDisplay.textContent = countdown;
            poops = [];

            gameMessage.style.display = 'none';
            restartButton.style.display = 'none';
            countdownDisplay.style.display = 'none'; // Hide countdown initially

            // Hide main game container, show character selection
            gameContainer.style.display = 'none';
            characterSelectionScreen.style.display = 'flex'; // Show the selection screen

            // Clear existing intervals to prevent multiple running instances
            clearInterval(toiletMoveInterval);
            clearInterval(countdownInterval);
            clearInterval(alvaroMoveIntervalId);
            cancelAnimationFrame(gameLoopId);

            displayCharacterSelection(); // Populate and display character buttons
        }

        // Function to populate and display character selection
        function displayCharacterSelection() {
            characterButtonsContainer.innerHTML = ''; // Clear previous buttons
            characterData.forEach(char => {
                const button = document.createElement('button');
                button.className = 'character-button';
                button.innerHTML = `${char.emoji}<br/><span>${char.name}</span>`;
                button.addEventListener('click', () => selectCharacter(char));
                characterButtonsContainer.appendChild(button);
            });
        }

        // Function to handle character selection and start the game
        function selectCharacter(char) {
            selectedCharacter = char; // Set the chosen character
            startGame(); // Start the actual game
        }

        // Function to start the actual game after character selection
        function startGame() {
            // Hide character selection, show main game container
            characterSelectionScreen.style.display = 'none';
            gameContainer.style.display = 'flex'; // Show the game container
            canvas.style.display = 'block'; // Make sure canvas is visible
            gameInfo.style.display = 'flex'; // Make sure game info is visible
            countdownDisplay.style.display = 'block'; // Show countdown now

            // Set √Ålvaro's initial state
            alvaro.x = boardSize / 2 - characterSize / 2;
            alvaro.y = boardSize / 2 - characterSize / 2;
            alvaro.moveDelay = alvaro.baseMoveDelay; // Reset √Ålvaro's speed
            alvaro.dx = cellSize; // Start √Ålvaro moving right by default
            alvaro.dy = 0;
            alvaro.lastX = alvaro.x; // Set initial last position
            alvaro.lastY = alvaro.y;

            // Set toilet's initial state
            toilet.x = Math.random() * (boardSize - toiletSize);
            toilet.y = Math.random() * (boardSize - toiletSize);
            toilet.speed = cellSize / 4; // Reset toilet speed

            // Start new intervals
            toiletMoveInterval = setInterval(moveToiletRandomly, 500); // Toilet changes direction every 0.5 seconds
            countdownInterval = setInterval(updateCountdown, 1000); // Countdown updates every 1 second
            alvaroMoveIntervalId = setInterval(moveAlvaro, alvaro.moveDelay); // Start √Ålvaro's movement

            gameLoopId = requestAnimationFrame(gameLoop); // Start the drawing loop
        }

        // Draw everything on the canvas
        function draw() {
            ctx.clearRect(0, 0, boardSize, boardSize); // Clear the canvas

            if (selectedCharacter) {
                // Draw Character Emoji
                ctx.font = `${characterSize}px Arial`;
                ctx.fillText(selectedCharacter.emoji, alvaro.x, alvaro.y + characterSize * 0.85); // Adjust for emoji baseline

                // Draw Character's Name
                ctx.font = `${cellSize * 0.8}px Inter`; // Smaller font for name
                ctx.textAlign = 'center'; // Center the text
                ctx.fillStyle = '#333'; // Dark color for text
                // Position name below character, adjusted by half of character width for centering
                ctx.fillText(selectedCharacter.name, alvaro.x + characterSize / 2, alvaro.y + characterSize + 10);
                ctx.textAlign = 'start'; // Reset text alignment for other drawings
            }


            // Draw Toilet
            ctx.font = `${toiletSize}px Arial`;
            ctx.fillText(toiletEmoji, toilet.x, toilet.y + toiletSize * 0.85); // Adjust for emoji baseline

            // Draw Poops
            ctx.font = `${poopSize}px Arial`;
            poops.forEach(p => {
                ctx.fillText(poopEmoji, p.x, p.y + poopSize * 0.85); // Adjust for emoji baseline
            });
        }

        // Update countdown
        function updateCountdown() {
            if (gameOver) return;

            countdown--;
            countdownDisplay.textContent = countdown;

            if (countdown <= 0) {
                // If countdown is zero, hide countdown display
                countdownDisplay.style.display = 'none';
            }
        }

        // Move toilet randomly
        function moveToiletRandomly() {
            if (gameOver) return;

            // Move toilet based on its current direction
            toilet.x += toilet.dx * toilet.speed;
            toilet.y += toilet.dy * toilet.speed;

            // Keep toilet within bounds and reverse direction if it hits a wall
            if (toilet.x < 0 || toilet.x > boardSize - toiletSize) {
                toilet.dx *= -1;
                toilet.x = Math.max(0, Math.min(toilet.x, boardSize - toiletSize)); // Clamp to boundary
                setRandomToiletDirection(); // Change direction again after hitting wall
            }
            if (toilet.y < 0 || toilet.y > boardSize - toiletSize) {
                toilet.dy *= -1;
                toilet.y = Math.max(0, Math.min(toilet.y, boardSize - toiletSize)); // Clamp to boundary
                setRandomToiletDirection(); // Change direction again after hitting wall
            }
        }

        // Update game state (primarily for collisions, drawing is separate)
        function update() {
            if (gameOver) return;

            // Collision detection: √Ålvaro and Toilet
            if (alvaro.x < toilet.x + toiletSize &&
                alvaro.x + characterSize > toilet.x &&
                alvaro.y < toilet.y + toiletSize &&
                alvaro.y + characterSize > toilet.y) {
                // Collision!
                score++;
                scoreDisplay.textContent = score;
                countdown = 3; // Reset countdown
                countdownDisplay.textContent = countdown;
                countdownDisplay.style.display = 'block'; // Show countdown again
                // poops = []; // Poops no longer disappear when toilet is caught

                // Increase toilet speed (e.g., 10% faster per catch)
                toilet.speed *= 1.1;

                // Increase √Ålvaro's speed (reduce moveDelay)
                alvaro.moveDelay = Math.max(alvaro.minMoveDelay, alvaro.moveDelay * 0.9);
                clearInterval(alvaroMoveIntervalId); // Clear old interval
                alvaroMoveIntervalId = setInterval(moveAlvaro, alvaro.moveDelay); // Start new interval with updated delay

                // Teleport toilet to a new random position
                toilet.x = Math.random() * (boardSize - toiletSize);
                toilet.y = Math.random() * (boardSize - toiletSize);
                setRandomToiletDirection(); // Set a new random direction for the teleported toilet
            }

            // Collision detection: √Ålvaro and Poop
            for (let i = 0; i < poops.length; i++) {
                const p = poops[i];
                if (alvaro.x < p.x + poopSize &&
                    alvaro.x + characterSize > p.x &&
                    alvaro.y < p.y + poopSize &&
                    alvaro.y + characterSize > p.y) {
                    // Collision with poop! Game Over
                    endGame("PIRIRI WINS");
                    break;
                }
            }
        }

        // End game function
        function endGame(message) {
            gameOver = true;
            clearInterval(toiletMoveInterval);
            clearInterval(countdownInterval);
            clearInterval(alvaroMoveIntervalId); // Stop √Ålvaro's movement interval
            cancelAnimationFrame(gameLoopId); // Stop the drawing loop

            gameMessage.textContent = message;
            gameMessage.style.display = 'block';
            restartButton.style.display = 'block';
            countdownDisplay.style.display = 'none'; // Hide countdown at game over
        }

        // Main game loop (for drawing and general updates like collisions)
        function gameLoop() {
            update();
            draw();
            if (!gameOver) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        // Event listener for keyboard input
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;

            // Change direction based on key, prevent immediate 180-degree turn
            // √Ålvaro's speed is cellSize per step
            switch (e.key) {
                case 'ArrowUp':
                    if (alvaro.dy === cellSize) return; // Prevent turning 180 degrees
                    alvaro.dy = -cellSize;
                    alvaro.dx = 0;
                    break;
                case 'ArrowDown':
                    if (alvaro.dy === -cellSize) return; // Prevent turning 180 degrees
                    alvaro.dy = cellSize;
                    alvaro.dx = 0;
                    break;
                case 'ArrowLeft':
                    if (alvaro.dx === cellSize) return; // Prevent turning 180 degrees
                    alvaro.dx = -cellSize;
                    alvaro.dy = 0;
                    break;
                case 'ArrowRight':
                    if (alvaro.dx === -cellSize) return; // Prevent turning 180 degrees
                    alvaro.dx = cellSize;
                    alvaro.dy = 0;
                    break;
            }
        });

        // Restart button event listener: goes back to character selection
        restartButton.addEventListener('click', initializeGame);

        // Initial setup on window load: starts the character selection process
        window.onload = function() {
            initializeGame();
            setRandomToiletDirection(); // Set initial direction for the toilet (toilet data is always present)
        };
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√Ålvaro e o Vaso Sanit√°rio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            overflow: hidden; /* Prevent scrolling if canvas is slightly larger */
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            position: relative; /* For countdown positioning */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; /* Ensure it takes full width of wrapper */
        }

        canvas {
            background-color: #e0f2f7; /* Light blue background for the board */
            border: 5px solid #a7d9ed;
            border-radius: 15px;
            display: block;
            touch-action: none; /* Prevent browser default touch actions */
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px; /* Match canvas max-width */
            margin-bottom: 15px;
            font-size: 1.25rem; /* text-xl */
            font-weight: bold;
            color: #333;
        }

        /* Power-up countdown display (repurposed for shovel or other timed power-ups) */
        .powerup-countdown-display {
            font-size: 1rem;
            color: #007bff; /* Blue for power-up timer */
            font-weight: bold;
            margin-left: 20px; /* Space from score */
            display: none; /* Hidden by default */
        }

        .countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem; /* Large font size for main countdown */
            font-weight: bold;
            color: rgba(0, 0, 0, 0.7);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through */
        }

        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem; /* text-5xl */
            font-weight: bold;
            color: #d32f2f; /* Red color for game over */
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px 40px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 20;
            display: none; /* Hidden by default */
        }

        .restart-button {
            margin-top: 20px;
            padding: 12px 25px;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            display: none; /* Hidden by default */
        }

        .restart-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        /* Difficulty Selection Screen */
        .difficulty-selection-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .difficulty-selection-screen h2 {
            font-size: 2.5rem;
            color: #333;
            margin-bottom: 25px;
            font-weight: bold;
        }

        .large-emoji {
            font-size: 10rem; /* Very large emoji */
            margin-bottom: 30px;
        }

        .difficulty-buttons {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            gap: 15px;
            width: 100%;
            max-width: 300px;
        }

        .difficulty-button {
            background: linear-gradient(145deg, #6200ee, #3700b3); /* Purple gradient */
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px 25px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .difficulty-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }


        /* Character Selection Screen */
        .character-selection-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 600px;
            width: 90%;
            text-align: center;
            /* Initially hidden */
        }

        .character-selection-screen h2 {
            font-size: 2.5rem;
            color: #333;
            margin-bottom: 25px;
            font-weight: bold;
        }

        .character-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 500px;
        }

        .character-button {
            background-color: #f8f8f8;
            border: 2px solid #ddd;
            border-radius: 15px;
            padding: 15px 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem; /* Emoji size */
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .character-button:hover {
            background-color: #e6e6e6;
            border-color: #b3b3b3;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .character-button span {
            font-size: 1rem; /* Name size */
            font-weight: 600;
            color: #555;
            margin-top: 5px;
        }

        /* Responsive adjustments for selection screens */
        @media (max-width: 768px) {
            .difficulty-selection-screen, .character-selection-screen {
                padding: 20px;
            }
            .difficulty-selection-screen h2, .character-selection-screen h2 {
                font-size: 2rem;
            }
            .large-emoji {
                font-size: 7rem;
            }
            .difficulty-button {
                font-size: 1rem;
                padding: 12px 20px;
            }
            .character-buttons {
                grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
                gap: 15px;
            }
            .character-button {
                font-size: 2rem;
                padding: 10px 5px;
            }
            .character-button span {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <!-- Difficulty Selection Screen -->
        <div id="difficultySelectionScreen" class="difficulty-selection-screen">
            <span class="large-emoji">üí©</span>
            <h2>Escolha a Dificuldade</h2>
            <div class="difficulty-buttons">
                <button id="normalDiffBtn" class="difficulty-button">Normal</button>
                <button id="hardDiffBtn" class="difficulty-button">Dif√≠cil</button>
                <button id="veryHardDiffBtn" class="difficulty-button">Muito Dif√≠cil</button>
            </div>
        </div>

        <!-- Character Selection Screen (initially hidden) -->
        <div id="characterSelectionScreen" class="character-selection-screen" style="display: none;">
            <h2>Escolha seu Personagem</h2>
            <div id="characterButtons" class="character-buttons">
                <!-- Character buttons will be inserted here by JavaScript -->
            </div>
        </div>

        <!-- Main Game Container (initially hidden) -->
        <div id="gameContainer" class="game-container" style="display: none;">
            <div class="game-info">
                <span>Vasos pegos: <span id="score">0</span></span>
                <span id="powerUpCountdownDisplay" class="powerup-countdown-display"></span>
            </div>
            <canvas id="gameCanvas"></canvas>
            <div id="countdown" class="countdown-display">3</div>
            <div id="gameMessage" class="game-message"></div>
            <button id="restartButton" class="restart-button">Jogar Novamente</button>
        </div>
    </div>

    <script>
        // Get canvas and its context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get info elements
        const scoreDisplay = document.getElementById('score');
        const countdownDisplay = document.getElementById('countdown');
        const powerUpCountdownDisplay = document.getElementById('powerUpCountdownDisplay');
        const gameMessage = document.getElementById('gameMessage');
        const restartButton = document.getElementById('restartButton');

        // New elements for selection screens
        const gameContainer = document.getElementById('gameContainer');
        const gameInfo = document.querySelector('.game-info');
        const difficultySelectionScreen = document.getElementById('difficultySelectionScreen'); // New
        const normalDiffBtn = document.getElementById('normalDiffBtn'); // New
        const hardDiffBtn = document.getElementById('hardDiffBtn');     // New
        const veryHardDiffBtn = document.getElementById('veryHardDiffBtn'); // New
        const characterSelectionScreen = document.getElementById('characterSelectionScreen');
        const characterButtonsContainer = document.getElementById('characterButtons');

        // Game settings
        const boardSize = 600;
        canvas.width = boardSize;
        canvas.height = boardSize;

        const cellSize = 20;
        const characterSize = cellSize;
        const toiletSize = cellSize * 2;
        const poopSize = cellSize;
        const itemSize = cellSize; // Generic size for power-up items

        // Global character data with updated emojis and added √ârico
        const characterData = [
            { name: '√Ålvaro', emoji: 'üèÉ‚Äç‚ôÇÔ∏è', powerUp: 'spawnToilet' }, // √Ålvaro agora tem o poder de spawnar vaso
            { name: 'Guilherme', emoji: 'ü•Å', powerUp: 'battery' }, // Guilherme tem a bateria
            { name: 'Franciela', emoji: 'üë∑‚Äç‚ôÄÔ∏è', powerUp: 'animals' }, // Franciela tem o poder de animais
            { name: 'Pandora', emoji: 'üêº', powerUp: 'randomClearPoops' }, // Pandora tem o poder de limpar coc√¥s aleatoriamente
            { name: 'Newton', emoji: 'üòê', powerUp: 'partyEmojis' }, // Newton tem o poder de emojis de festa
            { name: 'Larissa', emoji: 'üéæ', powerUp: 'tennisBalls' }, // Larissa tem as bolas de t√™nis
            { name: '√ârico', emoji: 'üë®‚Äçüî¨', powerUp: 'speed' }, // √ârico tem o poder de velocidade
            { name: 'Ana', emoji: 'üìö', powerUp: 'clearLastPoops' } // Ana tem o poder de limpar os √∫ltimos coc√¥s
        ];

        // Global emoji constants
        const poopEmoji = 'üí©';
        const toiletEmoji = 'üöΩ';
        const shovelEmoji = '‚õèÔ∏è'; // Corrected shovel emoji (no longer a power-up for anyone, but kept if needed)
        const batteryEmoji = 'üîã';
        const tennisBallEmoji = 'üéæ'; // Emoji for individual tennis balls and Larissa's item
        const dogEmoji = 'üêï‚Äçü¶∫'; // Dog emoji for Franciela
        const catEmoji = 'üêà‚Äç‚¨õ'; // Cat emoji for Franciela
        const partyEmoji = 'üéâ'; // Party emoji for Newton
        const cookieEmoji = 'üç™'; // Cookie for Pandora (no longer used for Pandora, but kept if needed)

        // Game state variables
        let selectedCharacter = null;
        let selectedDifficultyMultiplier = 1; // New: stores the difficulty multiplier

        let alvaro = {
            x: 0, y: 0, dx: 0, dy: 0,
            baseMoveDelay: 250, // This will now be dynamically adjusted by difficulty
            moveDelay: 250,
            minMoveDelay: 50,
            lastX: 0, lastY: 0,
            hasShovel: false, // Legacy, not used by Newton anymore but kept if another char gets it
            powerUpCountdown: 0, // Generic countdown for timed power-ups
            powerUpCountdownInterval: null, // Interval for generic power-up countdown
            // isPandoraPowerActive: false // No longer needed for Pandora's new power
        };

        let toilets = []; // Changed to an array for √Ålvaro's power-up

        // Power-up item states (only spawned if applicable to selected character)
        let batteryItem = { x: 0, y: 0, spawned: false };
        let tennisBallItem = { x: 0, y: 0, spawned: false };
        // let cookieItem = { x: 0, y: 0, spawned: false }; // No longer used for Pandora

        // Active power-up effects
        let activeTennisBalls = [];
        let activeAnimals = [];
        let activePartyEmojis = [];

        let score = 0;
        let countdown = 3;
        let gameOver = false;
        let poops = [];

        // Interval/Timeout IDs - Explicitly initialize to null
        let toiletMoveInterval = null;
        let countdownInterval = null;
        let alvaroMoveIntervalId = null;
        let gameLoopId = null;
        let tennisBallClearTimeoutId = null;
        let animalClearTimeoutId = null;
        let partyEmojiClearTimeoutId = null;

        // Constants for power-ups
        const ERICO_SPEED_MULTIPLIER = 0.33; // √ârico is 3x faster, so moveDelay is 1/3
        const BATTERY_CLEAR_RADIUS = 20 * cellSize; // Doubled: now 20 cells radius (400px)
        const TENNIS_BALL_ACTIVE_DURATION_SECONDS = 2;
        const NUM_TENNIS_BALLS_SPAWN = 10;
        const TENNIS_BALL_SPEED = cellSize / 2;

        const ANIMAL_ACTIVE_DURATION_SECONDS = 5;
        const ANIMAL_SPEED = cellSize / 3;

        const PARTY_EMOJI_DURATION_SECONDS = 2;
        const NUM_PARTY_EMOJIS_HORIZONTAL = 10;
        const NUM_PARTY_EMOJIS_VERTICAL = 10;
        const PARTY_EMOJI_BASE_SPEED = cellSize; // Base speed for Newton's emojis


        // Function to set toilet's new random direction
        function setRandomToiletDirection(toiletObj) {
            const directions = [-1, 0, 1];
            toiletObj.dx = directions[Math.floor(Math.random() * directions.length)];
            toiletObj.dy = directions[Math.floor(Math.random() * directions.length)];
        }

        // Moves √Ålvaro and drops poop if countdown is zero
        function moveAlvaro() {
            if (gameOver) return;

            alvaro.lastX = alvaro.x;
            alvaro.lastY = alvaro.y;

            alvaro.x += alvaro.dx;
            alvaro.y += alvaro.dy;

            alvaro.x = Math.max(0, Math.min(alvaro.x, boardSize - characterSize));
            alvaro.y = Math.max(0, Math.min(alvaro.y, boardSize - characterSize));

            // Stop √Ålvaro if he hits a boundary
            if ((alvaro.x === 0 && alvaro.dx < 0) || (alvaro.x === boardSize - characterSize && alvaro.dx > 0)) {
                alvaro.dx = 0;
            }
            if ((alvaro.y === 0 && alvaro.dy < 0) || (alvaro.y === boardSize - characterSize && alvaro.dy > 0)) {
                alvaro.dy = 0;
            }

            // Drop poop if countdown is 0 and √Ålvaro is moving
            if (countdown <= 0 && (alvaro.dx !== 0 || alvaro.dy !== 0)) {
                const poopX = alvaro.lastX + (characterSize - poopSize) / 2;
                const poopY = alvaro.lastY + (characterSize - poopSize) / 2;
                poops.push({ x: poopX, y: poopY });
            }
        }

        // Sets up the initial screen (difficulty selection)
        function initializeGame() {
            gameOver = false;
            score = 0;
            scoreDisplay.textContent = score;
            countdown = 3;
            countdownDisplay.textContent = countdown;
            poops = [];
            alvaro.hasShovel = false; // Legacy, not used by Newton anymore
            alvaro.powerUpCountdown = 0;
            // alvaro.isPandoraPowerActive = false; // No longer needed for Pandora's new power

            batteryItem.spawned = false;
            tennisBallItem.spawned = false;
            // cookieItem.spawned = false; // No longer used for Pandora
            activeTennisBalls = [];
            activeAnimals = [];
            activePartyEmojis = [];
            toilets = []; // Clear all toilets for new game

            gameMessage.style.display = 'none';
            restartButton.style.display = 'none';
            countdownDisplay.style.display = 'none';
            powerUpCountdownDisplay.style.display = 'none';

            // Show difficulty screen, hide others
            difficultySelectionScreen.style.display = 'flex';
            characterSelectionScreen.style.display = 'none';
            gameContainer.style.display = 'none';

            // Clear all intervals/timeouts to ensure a clean start
            if (toiletMoveInterval !== null) clearInterval(toiletMoveInterval);
            if (countdownInterval !== null) clearInterval(countdownInterval);
            if (alvaroMoveIntervalId !== null) clearInterval(alvaroMoveIntervalId);
            if (gameLoopId !== null) cancelAnimationFrame(gameLoopId);
            if (alvaro.powerUpCountdownInterval !== null) clearInterval(alvaro.powerUpCountdownInterval);
            if (tennisBallClearTimeoutId !== null) clearTimeout(tennisBallClearTimeoutId);
            if (animalClearTimeoutId !== null) clearTimeout(animalClearTimeoutId);
            if (partyEmojiClearTimeoutId !== null) clearTimeout(partyEmojiClearTimeoutId);

            setupDifficultyButtons(); // Attach event listeners for difficulty
        }

        // Sets up event listeners for difficulty buttons
        function setupDifficultyButtons() {
            normalDiffBtn.onclick = () => selectDifficulty(1);
            hardDiffBtn.onclick = () => selectDifficulty(2);
            veryHardDiffBtn.onclick = () => selectDifficulty(5);
        }

        // Handles difficulty selection and proceeds to character selection
        function selectDifficulty(multiplier) {
            selectedDifficultyMultiplier = multiplier;
            // Adjust the base movement delay based on difficulty. Lower delay means faster.
            alvaro.baseMoveDelay = 250 / selectedDifficultyMultiplier;

            // Hide difficulty screen, show character selection
            difficultySelectionScreen.style.display = 'none';
            displayCharacterSelection(); // This now calls to show character selection
        }


        // Populates and displays character selection buttons
        function displayCharacterSelection() {
            characterSelectionScreen.style.display = 'flex'; // Show character selection screen
            characterButtonsContainer.innerHTML = '';
            characterData.forEach(char => {
                const button = document.createElement('button');
                button.className = 'character-button';
                button.innerHTML = `${char.emoji}<br/><span>${char.name}</span>`;
                button.addEventListener('click', () => selectCharacter(char));
                characterButtonsContainer.appendChild(button);
            });
        }

        // Handles character selection and starts the game
        function selectCharacter(char) {
            selectedCharacter = char;
            startGame();
        }

        // Starts the main game loop and intervals
        function startGame() {
            characterSelectionScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            canvas.style.display = 'block';
            gameInfo.style.display = 'flex';
            countdownDisplay.style.display = 'block';

            // Set √Ålvaro's initial state
            alvaro.x = boardSize / 2 - characterSize / 2;
            alvaro.y = boardSize / 2 - characterSize / 2;
            alvaro.moveDelay = alvaro.baseMoveDelay; // Start with difficulty-adjusted base speed
            alvaro.dx = cellSize;
            alvaro.dy = 0;
            alvaro.lastX = alvaro.x;
            alvaro.lastY = alvaro.y;
            alvaro.hasShovel = false; // Legacy
            alvaro.powerUpCountdown = 0;
            // alvaro.isPandoraPowerActive = false; // No longer needed for Pandora's new power

            batteryItem.spawned = false;
            tennisBallItem.spawned = false;
            // cookieItem.spawned = false; // No longer used for Pandora
            activeTennisBalls = [];
            activeAnimals = [];
            activePartyEmojis = [];
            toilets = []; // Start with a fresh array of toilets

            // Initialize the first toilet
            let initialToilet = {
                x: Math.random() * (boardSize - toiletSize),
                y: Math.random() * (boardSize - toiletSize),
                dx: 0,
                dy: 0,
                speed: cellSize / 4 * selectedDifficultyMultiplier // Toilet speed also affected by difficulty
            };
            setRandomToiletDirection(initialToilet);
            toilets.push(initialToilet);


            // Adjust √Ålvaro's speed if √ârico is selected (multiplies on top of difficulty)
            if (selectedCharacter.powerUp === 'speed') {
                alvaro.moveDelay = alvaro.baseMoveDelay * ERICO_SPEED_MULTIPLIER;
            } else {
                alvaro.moveDelay = alvaro.baseMoveDelay; // Use the difficulty-adjusted base delay
            }

            toiletMoveInterval = setInterval(updateToiletsRandomly, 500 / selectedDifficultyMultiplier); // Toilet movement update frequency also affected
            countdownInterval = setInterval(updateCountdown, 1000 / selectedDifficultyMultiplier); // Countdown speed also affected
            alvaroMoveIntervalId = setInterval(moveAlvaro, alvaro.moveDelay);

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Draws all game elements on the canvas
        function draw() {
            ctx.clearRect(0, 0, boardSize, boardSize);

            // Draw Character
            if (selectedCharacter) {
                // Always draw the character's base emoji
                ctx.font = `${characterSize}px Arial`;
                ctx.fillText(selectedCharacter.emoji, alvaro.x, alvaro.y + characterSize * 0.85);

                // Draw power-up icon if character has it (e.g., shovel effect from Newton's old power-up, if implemented)
                // Current Newton power-up is partyEmojis, not a carried item.
                // This section might be removed or repurposed if no characters carry items.
                if (alvaro.hasShovel && selectedCharacter.powerUp === 'shovel') { // Still here if we re-implement shovel for someone
                    ctx.font = `${itemSize * 0.8}px Arial`;
                    ctx.fillText(shovelEmoji, alvaro.x + characterSize - (itemSize * 0.8), alvaro.y);
                }


                ctx.font = `${cellSize * 0.8}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillStyle = '#333';
                ctx.fillText(selectedCharacter.name, alvaro.x + characterSize / 2, alvaro.y + characterSize + 10);
                ctx.textAlign = 'start';
            }

            // Draw Battery item if spawned on board
            if (batteryItem.spawned) {
                ctx.font = `${itemSize}px Arial`;
                ctx.fillText(batteryEmoji, batteryItem.x, batteryItem.y + itemSize * 0.85);
            }

            // Draw Tennis Ball Item (the one Larissa picks up)
            if (tennisBallItem.spawned) {
                ctx.font = `${itemSize}px Arial`;
                ctx.fillText(tennisBallEmoji, tennisBallItem.x, tennisBallItem.y + itemSize * 0.85);
            }

            // Draw Cookie item if spawned on board (Pandora's old power) - REMOVED
            // if (cookieItem.spawned) {
            //     ctx.font = `${itemSize}px Arial`;
            //     ctx.fillText(cookieEmoji, cookieItem.x, cookieItem.y + itemSize * 0.85);
            // }

            // Draw active Tennis Balls
            ctx.font = `${poopSize * 0.8}px Arial`; // Smaller than poops
            activeTennisBalls.forEach(ball => {
                ctx.fillText(tennisBallEmoji, ball.x, ball.y + poopSize * 0.85);
            });

            // Draw active Animals (Franciela)
            ctx.font = `${itemSize}px Arial`;
            activeAnimals.forEach(animal => {
                ctx.fillText(animal.emoji, animal.x, animal.y + itemSize * 0.85);
            });

            // Draw active Party Emojis (Newton)
            ctx.font = `${itemSize}px Arial`;
            activePartyEmojis.forEach(pEmoji => {
                ctx.fillText(partyEmoji, pEmoji.x, pEmoji.y + itemSize * 0.85);
            });


            // Draw all Toilets
            ctx.font = `${toiletSize}px Arial`;
            toilets.forEach(t => {
                ctx.fillText(toiletEmoji, t.x, t.y + toiletSize * 0.85);
            });

            // Draw Poops
            ctx.font = `${poopSize}px Arial`;
            poops.forEach(p => {
                ctx.fillText(poopEmoji, p.x, p.y + poopSize * 0.85);
            });
        }

        // Updates main countdown timer
        function updateCountdown() {
            if (gameOver) return;

            countdown--;
            countdownDisplay.textContent = countdown;

            if (countdown <= 0) {
                countdownDisplay.style.display = 'none';
            }
        }

        // Function to update generic power-up countdown display
        function updatePowerUpCountdown() {
            if (gameOver) return;

            alvaro.powerUpCountdown--;
            powerUpCountdownDisplay.textContent = `Poder: ${alvaro.powerUpCountdown}s`;

            if (alvaro.powerUpCountdown <= 0) {
                clearInterval(alvaro.powerUpCountdownInterval);
                powerUpCountdownDisplay.style.display = 'none';
            }
        }

        // Moves all active toilets randomly
        function updateToiletsRandomly() {
            if (gameOver) return;

            toilets.forEach(t => {
                t.x += t.dx * t.speed;
                t.y += t.dy * t.speed;

                if (t.x < 0 || t.x > boardSize - toiletSize) {
                    t.dx *= -1;
                    t.x = Math.max(0, Math.min(t.x, boardSize - toiletSize));
                    setRandomToiletDirection(t); // Change direction again after hitting wall
                }
                if (t.y < 0 || t.y > boardSize - toiletSize) {
                    t.dy *= -1;
                    t.y = Math.max(0, Math.min(t.y, boardSize - toiletSize));
                    setRandomToiletDirection(t); // Change direction again after hitting wall
                }
            });
        }

        // Function to spawn Franciela's animals
        function spawnAnimals() {
            activeAnimals = []; // Clear previous animals before spawning new ones
            // Dog
            activeAnimals.push({
                x: Math.random() * (boardSize - itemSize),
                y: Math.random() * (boardSize - itemSize),
                dx: (Math.random() > 0.5 ? 1 : -1) * ANIMAL_SPEED * selectedDifficultyMultiplier, // Speed affected by difficulty
                dy: (Math.random() > 0.5 ? 1 : -1) * ANIMAL_SPEED * selectedDifficultyMultiplier,
                emoji: dogEmoji
            });
            // Cat
            activeAnimals.push({
                x: Math.random() * (boardSize - itemSize),
                y: Math.random() * (boardSize - itemSize),
                dx: (Math.random() > 0.5 ? 1 : -1) * ANIMAL_SPEED * selectedDifficultyMultiplier,
                dy: (Math.random() > 0.5 ? 1 : -1) * ANIMAL_SPEED * selectedDifficultyMultiplier,
                emoji: catEmoji
            });

            animalClearTimeoutId = setTimeout(() => {
                activeAnimals = []; // Clear animals after duration
            }, ANIMAL_ACTIVE_DURATION_SECONDS * 1000);
        }

        // Function to spawn Newton's party emojis
        function spawnPartyEmojis() {
            activePartyEmojis = []; // Clear previous party emojis
            const currentPartyEmojiSpeed = PARTY_EMOJI_BASE_SPEED * selectedDifficultyMultiplier / 2; // Half the speed

            // 10 Horizontal Emojis
            for (let i = 0; i < NUM_PARTY_EMOJIS_HORIZONTAL; i++) {
                activePartyEmojis.push({
                    x: -itemSize, // Start off-screen left
                    y: Math.random() * (boardSize - itemSize),
                    dx: currentPartyEmojiSpeed, // Use adjusted speed
                    dy: (Math.random() - 0.5) * currentPartyEmojiSpeed * 0.5 // Slight vertical variation
                });
            }
            // 10 Vertical Emojis
            for (let i = 0; i < NUM_PARTY_EMOJIS_VERTICAL; i++) {
                activePartyEmojis.push({
                    x: Math.random() * (boardSize - itemSize),
                    y: -itemSize, // Start off-screen top
                    dx: (Math.random() - 0.5) * currentPartyEmojiSpeed * 0.5, // Slight horizontal variation
                    dy: currentPartyEmojiSpeed // Use adjusted speed
                });
            }

            partyEmojiClearTimeoutId = setTimeout(() => {
                activePartyEmojis = []; // Clear party emojis after duration
            }, PARTY_EMOJI_DURATION_SECONDS * 1000);
        }

        // Main game logic update (collisions, scoring, item spawning)
        function update() {
            if (gameOver) return;

            // Update active tennis balls position and check collisions with poops
            for (let i = activeTennisBalls.length - 1; i >= 0; i--) {
                const ball = activeTennisBalls[i];

                ball.x += ball.dx;
                ball.y += ball.dy;

                // Bounce off walls
                if (ball.x < 0 || ball.x > boardSize - itemSize) {
                    ball.dx *= -1;
                    ball.x = Math.max(0, Math.min(ball.x, boardSize - itemSize));
                }
                if (ball.y < 0 || ball.y > boardSize - itemSize) {
                    ball.dy *= -1;
                    ball.y = Math.max(0, Math.min(ball.y, boardSize - itemSize));
                }

                // Check collision with poops
                for (let j = poops.length - 1; j >= 0; j--) {
                    const poop = poops[j];
                    if (ball.x < poop.x + poopSize &&
                        ball.x + itemSize > poop.x &&
                        ball.y < poop.y + poopSize &&
                        ball.y + itemSize > poop.y) {
                        poops.splice(j, 1); // Remove poop
                    }
                }
            }

            // Update active animals position and check collisions with poops
            for (let i = activeAnimals.length - 1; i >= 0; i--) {
                const animal = activeAnimals[i];

                animal.x += animal.dx;
                animal.y += animal.dy;

                // Bounce off walls
                if (animal.x < 0 || animal.x > boardSize - itemSize) {
                    animal.dx *= -1;
                    animal.x = Math.max(0, Math.min(animal.x, boardSize - itemSize));
                }
                if (animal.y < 0 || animal.y > boardSize - itemSize) {
                    animal.dy *= -1;
                    animal.y = Math.max(0, Math.min(animal.y, boardSize - itemSize));
                }

                // Check collision with poops
                for (let j = poops.length - 1; j >= 0; j--) {
                    const poop = poops[j];
                    if (animal.x < poop.x + poopSize &&
                        animal.x + itemSize > poop.x &&
                        animal.y < poop.y + poopSize &&
                        animal.y + itemSize > poop.y) {
                        poops.splice(j, 1); // Remove poop
                    }
                }
            }

            // Update active party emojis position and check collisions with poops
            for (let i = activePartyEmojis.length - 1; i >= 0; i--) {
                const pEmoji = activePartyEmojis[i];

                pEmoji.x += pEmoji.dx;
                pEmoji.y += pEmoji.dy;

                // Simple boundary check: remove if off-screen (or could bounce)
                if (pEmoji.x > boardSize || pEmoji.x < -itemSize || pEmoji.y > boardSize || pEmoji.y < -itemSize) {
                     activePartyEmojis.splice(i, 1); // Remove if off-screen
                     continue; // Move to next iteration
                }

                // Check collision with poops
                for (let j = poops.length - 1; j >= 0; j--) {
                    const poop = poops[j];
                    if (pEmoji.x < poop.x + poopSize &&
                        pEmoji.x + itemSize > poop.x &&
                        pEmoji.y < poop.y + poopSize &&
                        pEmoji.y + itemSize > poop.y) {
                        poops.splice(j, 1); // Remove poop
                    }
                }
            }

            // Collision detection: √Ålvaro and Toilets (loop through all active toilets)
            for (let toiletIndex = toilets.length - 1; toiletIndex >= 0; toiletIndex--) {
                const currentToilet = toilets[toiletIndex];

                if (alvaro.x < currentToilet.x + toiletSize &&
                    alvaro.x + characterSize > currentToilet.x &&
                    alvaro.y < currentToilet.y + toiletSize &&
                    alvaro.y + characterSize > currentToilet.y) {
                    // Collision!
                    score++;
                    scoreDisplay.textContent = score;
                    countdown = 3;
                    countdownDisplay.textContent = countdown;
                    countdownDisplay.style.display = 'block';

                    currentToilet.speed *= 1.1; // Increase speed of the caught toilet
                    alvaro.moveDelay = Math.max(alvaro.minMoveDelay, alvaro.moveDelay * 0.9);
                    clearInterval(alvaroMoveIntervalId);
                    alvaroMoveIntervalId = setInterval(moveAlvaro, alvaro.moveDelay);

                    // Teleport the caught toilet to a new random position
                    currentToilet.x = Math.random() * (boardSize - toiletSize);
                    currentToilet.y = Math.random() * (boardSize - toiletSize);
                    setRandomToiletDirection(currentToilet);

                    // Power-up spawn/activation logic
                    if (score > 0) {
                        if (selectedCharacter.powerUp === 'spawnToilet' && score % 10 === 0) { // √Ålvaro's power every 10
                            let newToilet = {
                                x: Math.random() * (boardSize - toiletSize),
                                y: Math.random() * (boardSize - toiletSize),
                                dx: 0,
                                dy: 0,
                                speed: cellSize / 4 * selectedDifficultyMultiplier // New toilets speed also affected by difficulty
                            };
                            setRandomToiletDirection(newToilet);
                            toilets.push(newToilet);
                        } else if (selectedCharacter.powerUp === 'clearLastPoops') { // Ana's power (every toilet caught)
                             const poopsToRemove = Math.min(5, poops.length); // Ensure not to remove more than exist
                             poops.splice(poops.length - poopsToRemove, poopsToRemove);
                        } else if (selectedCharacter.powerUp === 'randomClearPoops' && score % 5 === 0) { // Pandora's new power every 5
                            if (poops.length > 0) {
                                const numPoopsToRemove = Math.ceil(poops.length / 2);
                                for (let i = 0; i < numPoopsToRemove; i++) {
                                    const randomIndex = Math.floor(Math.random() * poops.length);
                                    poops.splice(randomIndex, 1);
                                }
                            }
                        }
                        // Other character power-ups that spawn items or trigger every 5 toilets caught
                        if (score % 5 === 0) {
                            switch (selectedCharacter.powerUp) {
                                case 'battery':
                                    if (!batteryItem.spawned) {
                                        batteryItem.x = Math.random() * (boardSize - itemSize);
                                        batteryItem.y = Math.random() * (boardSize - itemSize);
                                        batteryItem.spawned = true;
                                    }
                                    break;
                                case 'tennisBalls':
                                    if (!tennisBallItem.spawned) {
                                        tennisBallItem.x = Math.random() * (boardSize - itemSize);
                                        tennisBallItem.y = Math.random() * (boardSize - itemSize);
                                        tennisBallItem.spawned = true;
                                    }
                                    break;
                                case 'partyEmojis': // Newton's direct power-up
                                    if (activePartyEmojis.length === 0) { // Only spawn if none are active
                                        spawnPartyEmojis();
                                    }
                                    break;
                                case 'animals': // Franciela's direct power-up
                                    if (activeAnimals.length === 0) { // Only spawn if none are active
                                        spawnAnimals();
                                    }
                                    break;
                                // case 'areaClean': // Pandora's old power, removed
                                //     if (!cookieItem.spawned) {
                                //         cookieItem.x = Math.random() * (boardSize - itemSize);
                                //         cookieItem.y = Math.random() * (boardSize - itemSize);
                                //         cookieItem.spawned = true;
                                //     }
                                //     break;
                            }
                        }
                    }
                }
            }


            // Collision detection: √Ålvaro and Battery Item (only for Guilherme)
            if (selectedCharacter && selectedCharacter.powerUp === 'battery' && batteryItem.spawned &&
                alvaro.x < batteryItem.x + itemSize &&
                alvaro.x + characterSize > batteryItem.x &&
                alvaro.y < batteryItem.y + itemSize &&
                alvaro.y + characterSize > batteryItem.y) {
                // √Ålvaro (Guilherme) picked up the battery!
                batteryItem.spawned = false;

                const alvaroCenterX = alvaro.x + characterSize / 2;
                const alvaroCenterY = alvaro.y + characterSize / 2;

                poops = poops.filter(p => {
                    const poopCenterX = p.x + poopSize / 2;
                    const poopCenterY = p.y + poopSize / 2;
                    const distance = Math.sqrt(
                        Math.pow(alvaroCenterX - poopCenterX, 2) +
                        Math.pow(alvaroCenterY - poopCenterY, 2)
                    );
                    return distance > BATTERY_CLEAR_RADIUS; // Use doubled radius
                });
            }

            // Collision detection: √Ålvaro and Tennis Ball Item (only for Larissa)
            if (selectedCharacter && selectedCharacter.powerUp === 'tennisBalls' && tennisBallItem.spawned &&
                alvaro.x < tennisBallItem.x + itemSize &&
                alvaro.x + characterSize > tennisBallItem.x &&
                alvaro.y < tennisBallItem.y + itemSize &&
                alvaro.y + characterSize > tennisBallItem.y) {
                // √Ålvaro (Larissa) picked up the tennis ball item!
                tennisBallItem.spawned = false; // Remove item from board
                activeTennisBalls = []; // Clear any previous active balls

                // Spawn NUM_TENNIS_BALLS_SPAWN tennis balls
                for (let i = 0; i < NUM_TENNIS_BALLS_SPAWN; i++) {
                    const angle = Math.random() * Math.PI * 2; // Random direction
                    activeTennisBalls.push({
                        x: alvaro.x + characterSize / 2 - itemSize / 2, // Start at √Ålvaro's center
                        y: alvaro.y + characterSize / 2 - itemSize / 2,
                        dx: Math.cos(angle) * TENNIS_BALL_SPEED * selectedDifficultyMultiplier, // Speed affected by difficulty
                        dy: Math.sin(angle) * TENNIS_BALL_SPEED * selectedDifficultyMultiplier,
                    });
                }
                // Start a global timer to remove all balls after 2 seconds
                clearTimeout(tennisBallClearTimeoutId);
                tennisBallClearTimeoutId = setTimeout(() => {
                    activeTennisBalls = []; // Clear all tennis balls
                }, TENNIS_BALL_ACTIVE_DURATION_SECONDS * 1000);
            }

            // Collision detection: √Ålvaro and Poop
            for (let i = poops.length - 1; i >= 0; i--) {
                const p = poops[i];
                if (alvaro.x < p.x + poopSize &&
                    alvaro.x + characterSize > p.x &&
                    alvaro.y < p.y + poopSize &&
                    alvaro.y + characterSize > p.y) {
                    // Collision with poop!
                    // Pandora's old power (areaClean) has been replaced.
                    // If a character were to have a temporary immunity/cleanse, that logic would go here.
                    endGame("PIRIRI WINS"); // Game over if no special cleaning power active
                    break;
                }
            }
        }

        // Ends the game and displays message
        function endGame(message) {
            gameOver = true;
            if (toiletMoveInterval !== null) clearInterval(toiletMoveInterval);
            if (countdownInterval !== null) clearInterval(countdownInterval);
            if (alvaroMoveIntervalId !== null) clearInterval(alvaroMoveIntervalId);
            if (gameLoopId !== null) cancelAnimationFrame(gameLoopId);
            if (alvaro.powerUpCountdownInterval !== null) clearInterval(alvaro.powerUpCountdownInterval); // Clear generic power-up countdown
            if (tennisBallClearTimeoutId !== null) clearTimeout(tennisBallClearTimeoutId);
            if (animalClearTimeoutId !== null) clearTimeout(animalClearTimeoutId);
            if (partyEmojiClearTimeoutId !== null) clearTimeout(partyEmojiClearTimeoutId);


            gameMessage.textContent = message;
            gameMessage.style.display = 'block';
            restartButton.style.display = 'block';
            countdownDisplay.style.display = 'none';
            powerUpCountdownDisplay.style.display = 'none';
        }

        // Main game drawing loop
        function gameLoop() {
            update();
            draw();
            if (!gameOver) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        // Keyboard input for √Ålvaro's movement
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;

            switch (e.key) {
                case 'ArrowUp':
                    if (alvaro.dy === cellSize) return;
                    alvaro.dy = -cellSize;
                    alvaro.dx = 0;
                    break;
                case 'ArrowDown':
                    if (alvaro.dy === -cellSize) return;
                    alvaro.dy = cellSize;
                    alvaro.dx = 0;
                    break;
                case 'ArrowLeft':
                    if (alvaro.dx === cellSize) return;
                    alvaro.dx = -cellSize;
                    alvaro.dy = 0;
                    break;
                case 'ArrowRight':
                    if (alvaro.dx === -cellSize) return;
                    alvaro.dx = cellSize;
                    alvaro.dy = 0;
                    break;
            }
        });

        // Restart button event listener
        restartButton.addEventListener('click', initializeGame);

        // Initial setup on window load
        window.onload = function() {
            initializeGame();
        };
    </script>
</body>
</html>
